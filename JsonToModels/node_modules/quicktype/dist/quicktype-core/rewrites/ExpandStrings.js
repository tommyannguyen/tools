"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const collection_utils_1 = require("collection-utils");
const TypeUtils_1 = require("../TypeUtils");
const Support_1 = require("../support/Support");
const TypeAttributes_1 = require("../TypeAttributes");
const StringTypes_1 = require("../StringTypes");
const MIN_LENGTH_FOR_ENUM = 10;
function shouldBeEnum(enumCases) {
    const keys = Array.from(enumCases.keys());
    Support_1.assert(keys.length > 0, "How did we end up with zero enum cases?");
    if (keys.length === 1 && keys[0] === "")
        return false;
    const someCaseIsNotNumber = collection_utils_1.iterableSome(keys, key => /^(\-|\+)?[0-9]+(\.[0-9]+)?$/.test(key) === false);
    const numValues = collection_utils_1.iterableReduce(enumCases.values(), 0, (a, b) => a + b);
    return numValues >= MIN_LENGTH_FOR_ENUM && enumCases.size < Math.sqrt(numValues) && someCaseIsNotNumber;
}
function expandStrings(ctx, graph, inference) {
    const stringTypeMapping = ctx.stringTypeMapping;
    function replaceString(group, builder, forwardingRef) {
        Support_1.assert(group.size === 1);
        const t = Support_1.defined(collection_utils_1.iterableFirst(group));
        const stringTypes = TypeUtils_1.stringTypesForType(t);
        const attributes = collection_utils_1.mapFilter(t.getAttributes(), a => a !== stringTypes);
        const mappedStringTypes = stringTypes.applyStringTypeMapping(stringTypeMapping);
        if (!mappedStringTypes.isRestricted) {
            return builder.getStringType(attributes, StringTypes_1.StringTypes.unrestricted, forwardingRef);
        }
        const types = [];
        const cases = Support_1.defined(mappedStringTypes.cases);
        if (cases.size > 0) {
            if (inference === "all" || (inference === "infer" && shouldBeEnum(cases))) {
                types.push(builder.getEnumType(TypeAttributes_1.emptyTypeAttributes, new Set(cases.keys())));
            }
            else {
                return builder.getStringType(attributes, StringTypes_1.StringTypes.unrestricted, forwardingRef);
            }
        }
        types.push(...Array.from(mappedStringTypes.transformations).map(k => builder.getPrimitiveType(k)));
        Support_1.assert(types.length > 0, "We got an empty string type");
        return builder.getUnionType(attributes, new Set(types), forwardingRef);
    }
    const allStrings = Array.from(graph.allTypesUnordered())
        .filter(t => t.kind === "string" && TypeUtils_1.stringTypesForType(t).isRestricted)
        .map(t => [t]);
    return graph.rewrite("expand strings", stringTypeMapping, false, allStrings, ctx.debugPrintReconstitution, replaceString);
}
exports.expandStrings = expandStrings;
