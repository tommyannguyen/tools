"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const collection_utils_1 = require("collection-utils");
const TypeUtils_1 = require("../TypeUtils");
const Strings_1 = require("../support/Strings");
const Support_1 = require("../support/Support");
const Source_1 = require("../Source");
const Naming_1 = require("../Naming");
const ConvenienceRenderer_1 = require("../ConvenienceRenderer");
const TargetLanguage_1 = require("../TargetLanguage");
const RendererOptions_1 = require("../RendererOptions");
const unicode = require("unicode-properties");
exports.javaScriptOptions = {
    runtimeTypecheck: new RendererOptions_1.BooleanOption("runtime-typecheck", "Verify JSON.parse results at runtime", true)
};
class JavaScriptTargetLanguage extends TargetLanguage_1.TargetLanguage {
    constructor(displayName = "JavaScript", names = ["javascript", "js", "jsx"], extension = "js") {
        super(displayName, names, extension);
    }
    getOptions() {
        return [exports.javaScriptOptions.runtimeTypecheck];
    }
    get supportsOptionalClassProperties() {
        return true;
    }
    get supportsFullObjectType() {
        return true;
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new JavaScriptRenderer(this, renderContext, RendererOptions_1.getOptionValues(exports.javaScriptOptions, untypedOptionValues));
    }
}
exports.JavaScriptTargetLanguage = JavaScriptTargetLanguage;
function isStartCharacter(utf16Unit) {
    return unicode.isAlphabetic(utf16Unit) || utf16Unit === 0x5f; // underscore
}
function isPartCharacter(utf16Unit) {
    const category = unicode.getCategory(utf16Unit);
    return ["Nd", "Pc", "Mn", "Mc"].indexOf(category) >= 0 || isStartCharacter(utf16Unit);
}
const legalizeName = Strings_1.utf16LegalizeCharacters(isPartCharacter);
function typeNameStyle(original) {
    const words = Strings_1.splitIntoWords(original);
    return Strings_1.combineWords(words, legalizeName, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, Strings_1.allUpperWordStyle, Strings_1.allUpperWordStyle, "", isStartCharacter);
}
function propertyNameStyle(original) {
    const escaped = Strings_1.utf16StringEscape(original);
    const quoted = `"${escaped}"`;
    if (original.length === 0) {
        return quoted;
    }
    else if (!isStartCharacter(original.codePointAt(0))) {
        return quoted;
    }
    else if (escaped !== original) {
        return quoted;
    }
    else if (legalizeName(original) !== original) {
        return quoted;
    }
    else {
        return original;
    }
}
class JavaScriptRenderer extends ConvenienceRenderer_1.ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _jsOptions) {
        super(targetLanguage, renderContext);
        this._jsOptions = _jsOptions;
        this.typeMapTypeFor = (t) => {
            if (["class", "object", "enum"].indexOf(t.kind) >= 0) {
                return ['r("', this.nameForNamedType(t), '")'];
            }
            return TypeUtils_1.matchType(t, _anyType => '"any"', _nullType => `null`, _boolType => `true`, _integerType => `0`, _doubleType => `3.14`, _stringType => `""`, arrayType => ["a(", this.typeMapTypeFor(arrayType.items), ")"], _classType => Support_1.panic("We handled this above"), mapType => ["m(", this.typeMapTypeFor(mapType.values), ")"], _enumType => Support_1.panic("We handled this above"), unionType => {
                const children = Array.from(unionType.getChildren()).map(this.typeMapTypeFor);
                return ["u(", ...collection_utils_1.arrayIntercalate(", ", children), ")"];
            });
        };
        this.emitTypeMap = () => {
            const { any: anyAnnotation } = this.typeAnnotations;
            this.emitBlock(`const typeMap${anyAnnotation} = `, ";", () => {
                this.forEachObject("none", (t, name) => {
                    const additionalProperties = t.getAdditionalProperties();
                    const additional = additionalProperties !== undefined ? this.typeMapTypeFor(additionalProperties) : "false";
                    this.emitBlock(['"', name, '": o('], [", ", additional, "),"], () => {
                        this.forEachClassProperty(t, "none", (propName, _propJsonName, property) => {
                            this.emitLine(propName, ": ", this.typeMapTypeForProperty(property), ",");
                        });
                    });
                });
                this.forEachEnum("none", (e, name) => {
                    this.emitLine('"', name, '": [');
                    this.indent(() => {
                        this.forEachEnumCase(e, "none", (_caseName, jsonName) => {
                            this.emitLine(`"${Strings_1.utf16StringEscape(jsonName)}",`);
                        });
                    });
                    this.emitLine("],");
                });
            });
        };
    }
    makeNamedTypeNamer() {
        return new Naming_1.Namer("types", typeNameStyle, []);
    }
    namerForObjectProperty() {
        return new Naming_1.Namer("properties", propertyNameStyle, []);
    }
    makeUnionMemberNamer() {
        return null;
    }
    makeEnumCaseNamer() {
        return new Naming_1.Namer("enum-cases", typeNameStyle, []);
    }
    namedTypeToNameForTopLevel(type) {
        return TypeUtils_1.directlyReachableSingleNamedType(type);
    }
    makeNameForProperty(c, className, p, jsonName, _assignedName) {
        // Ignore the assigned name
        return super.makeNameForProperty(c, className, p, jsonName, undefined);
    }
    emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, " * ", "/**", " */");
    }
    typeMapTypeForProperty(p) {
        const typeMap = this.typeMapTypeFor(p.type);
        if (!p.isOptional) {
            return typeMap;
        }
        return ["u(undefined, ", typeMap, ")"];
    }
    emitBlock(source, end, emit) {
        this.emitLine(source, "{");
        this.indent(emit);
        this.emitLine("}", end);
    }
    deserializerFunctionName(name) {
        return ["to", name];
    }
    deserializerFunctionLine(_t, name) {
        return ["function ", this.deserializerFunctionName(name), "(json)"];
    }
    serializerFunctionName(name) {
        const camelCaseName = Source_1.modifySource(Strings_1.camelCase, name);
        return [camelCaseName, "ToJson"];
    }
    serializerFunctionLine(_t, name) {
        return ["function ", this.serializerFunctionName(name), "(value)"];
    }
    get moduleLine() {
        return undefined;
    }
    get castFunctionLine() {
        return "function cast(obj, typ)";
    }
    get typeAnnotations() {
        return { any: "", anyArray: "", anyMap: "", string: "", stringArray: "", boolean: "" };
    }
    emitConvertModuleBody() {
        this.forEachTopLevel("interposing", (t, name) => {
            this.emitBlock([this.deserializerFunctionLine(t, name), " "], "", () => {
                if (!this._jsOptions.runtimeTypecheck) {
                    this.emitLine("return JSON.parse(json);");
                }
                else {
                    this.emitLine("return cast(JSON.parse(json), ", this.typeMapTypeFor(t), ");");
                }
            });
            this.ensureBlankLine();
            this.emitBlock([this.serializerFunctionLine(t, name), " "], "", () => {
                this.emitLine("return JSON.stringify(value, null, 2);");
            });
        });
        if (this._jsOptions.runtimeTypecheck) {
            const { any: anyAnnotation, anyArray: anyArrayAnnotation, anyMap: anyMapAnnotation, string: stringAnnotation, stringArray: stringArrayAnnotation, boolean: booleanAnnotation } = this.typeAnnotations;
            this.ensureBlankLine();
            this.emitMultiline(`${this.castFunctionLine} {
    if (!isValid(typ, obj)) {
        throw Error(\`Invalid value\`);
    }
    return obj;
}

function isValid(typ${anyAnnotation}, val${anyAnnotation})${booleanAnnotation} {
    if (typ === "any") { return true; }
    if (typ === null) { return val === null; }
    if (typ === false) { return false; }
    while (typeof typ === "object" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) { return isValidEnum(typ, val); }
    if (typeof typ === "object") {
        return typ.hasOwnProperty("unionMembers") ? isValidUnion(typ.unionMembers, val)
            : typ.hasOwnProperty("arrayItems")    ? isValidArray(typ.arrayItems, val)
            : typ.hasOwnProperty("props")         ? isValidObject(typ.props, typ.additional, val)
            : false;
    }
    return isValidPrimitive(typ, val);
}

function isValidPrimitive(typ${stringAnnotation}, val${anyAnnotation}) {
    return typeof typ === typeof val;
}

function isValidUnion(typs${anyArrayAnnotation}, val${anyAnnotation})${booleanAnnotation} {
    // val must validate against one typ in typs
    return typs.some((typ) => isValid(typ, val));
}

function isValidEnum(cases${stringArrayAnnotation}, val${anyAnnotation})${booleanAnnotation} {
    return cases.indexOf(val) !== -1;
}

function isValidArray(typ${anyAnnotation}, val${anyAnnotation})${booleanAnnotation} {
    // val must be an array with no invalid elements
    return Array.isArray(val) && val.every((element) => {
        return isValid(typ, element);
    });
}

function isValidObject(props${anyMapAnnotation}, additional${anyAnnotation}, val${anyAnnotation})${booleanAnnotation} {
    if (val === null || typeof val !== "object" || Array.isArray(val)) {
        return false;
    }
    return Object.getOwnPropertyNames(val).every((key) => {
        const prop = val[key];
        if (Object.prototype.hasOwnProperty.call(props, key)) {
            return isValid(props[key], prop);
        }
        return isValid(additional, prop);
    });
}

function a(typ${anyAnnotation}) {
    return { arrayItems: typ };
}

function u(...typs${anyArrayAnnotation}) {
    return { unionMembers: typs };
}

function o(props${anyMapAnnotation}, additional${anyAnnotation}) {
    return { props, additional };
}

function m(additional${anyAnnotation}) {
    return { props: {}, additional };
}

function r(name${stringAnnotation}) {
    return { ref: name };
}
`);
            this.emitTypeMap();
        }
    }
    emitConvertModule() {
        this.ensureBlankLine();
        this.emitMultiline(`// Converts JSON strings to/from your types`);
        if (this._jsOptions.runtimeTypecheck) {
            this.emitMultiline(`// and asserts the results of JSON.parse at runtime`);
        }
        const moduleLine = this.moduleLine;
        if (moduleLine === undefined) {
            this.emitConvertModuleBody();
        }
        else {
            this.emitBlock([moduleLine, " "], "", () => this.emitConvertModuleBody());
        }
    }
    emitTypes() {
        return;
    }
    emitUsageImportComment() {
        this.emitLine('//   const Convert = require("./file");');
    }
    emitUsageComments() {
        this.emitMultiline(`// To parse this data:
//`);
        this.emitUsageImportComment();
        this.emitLine("//");
        this.forEachTopLevel("none", (_t, name) => {
            const camelCaseName = Source_1.modifySource(Strings_1.camelCase, name);
            this.emitLine("//   const ", camelCaseName, " = Convert.to", name, "(json);");
        });
        if (this._jsOptions.runtimeTypecheck) {
            this.emitLine("//");
            this.emitLine("// These functions will throw an error if the JSON doesn't");
            this.emitLine("// match the expected interface, even if the JSON is valid.");
        }
    }
    emitModuleExports() {
        this.ensureBlankLine();
        this.emitBlock("module.exports = ", ";", () => {
            this.forEachTopLevel("none", (_, name) => {
                const serializer = this.serializerFunctionName(name);
                const deserializer = this.deserializerFunctionName(name);
                this.emitLine('"', serializer, '": ', serializer, ",");
                this.emitLine('"', deserializer, '": ', deserializer, ",");
            });
        });
    }
    emitSourceStructure() {
        if (this.leadingComments !== undefined) {
            this.emitCommentLines(this.leadingComments);
        }
        else {
            this.emitUsageComments();
        }
        this.emitTypes();
        this.emitConvertModule();
        this.emitModuleExports();
    }
}
exports.JavaScriptRenderer = JavaScriptRenderer;
