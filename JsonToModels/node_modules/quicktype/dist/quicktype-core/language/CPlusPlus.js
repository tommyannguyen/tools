"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const collection_utils_1 = require("collection-utils");
const TargetLanguage_1 = require("../TargetLanguage");
const Type_1 = require("../Type");
const TypeUtils_1 = require("../TypeUtils");
const Naming_1 = require("../Naming");
const Source_1 = require("../Source");
const Annotation_1 = require("../Annotation");
const Strings_1 = require("../support/Strings");
const Support_1 = require("../support/Support");
const ConvenienceRenderer_1 = require("../ConvenienceRenderer");
const RendererOptions_1 = require("../RendererOptions");
const Support_2 = require("../support/Support");
const pascalValue = ["pascal-case", "pascal"];
const underscoreValue = ["underscore-case", "underscore"];
const camelValue = ["camel-case", "camel"];
const upperUnderscoreValue = ["upper-underscore-case", "upper-underscore"];
const pascalUpperAcronymsValue = ["pascal-case-upper-acronyms", "pascal-upper-acronyms"];
const camelUpperAcronymsValue = ["camel-case-upper-acronyms", "camel-upper-acronyms"];
exports.cPlusPlusOptions = {
    justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
    namespace: new RendererOptions_1.StringOption("namespace", "Name of the generated namespace(s)", "NAME", "quicktype"),
    typeNamingStyle: new RendererOptions_1.EnumOption("type-style", "Naming style for types", [
        pascalValue,
        underscoreValue,
        camelValue,
        upperUnderscoreValue,
        pascalUpperAcronymsValue,
        camelUpperAcronymsValue
    ]),
    memberNamingStyle: new RendererOptions_1.EnumOption("member-style", "Naming style for members", [
        underscoreValue,
        pascalValue,
        camelValue,
        upperUnderscoreValue,
        pascalUpperAcronymsValue,
        camelUpperAcronymsValue
    ]),
    enumeratorNamingStyle: new RendererOptions_1.EnumOption("enumerator-style", "Naming style for enumerators", [
        upperUnderscoreValue,
        underscoreValue,
        pascalValue,
        camelValue,
        pascalUpperAcronymsValue,
        camelUpperAcronymsValue
    ])
};
class CPlusPlusTargetLanguage extends TargetLanguage_1.TargetLanguage {
    constructor(displayName = "C++", names = ["c++", "cpp", "cplusplus"], extension = "cpp") {
        super(displayName, names, extension);
    }
    getOptions() {
        return [
            exports.cPlusPlusOptions.justTypes,
            exports.cPlusPlusOptions.namespace,
            exports.cPlusPlusOptions.typeNamingStyle,
            exports.cPlusPlusOptions.memberNamingStyle,
            exports.cPlusPlusOptions.enumeratorNamingStyle
        ];
    }
    get supportsUnionsWithBothNumberTypes() {
        return true;
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new CPlusPlusRenderer(this, renderContext, RendererOptions_1.getOptionValues(exports.cPlusPlusOptions, untypedOptionValues));
    }
}
exports.CPlusPlusTargetLanguage = CPlusPlusTargetLanguage;
const legalizeName = Strings_1.legalizeCharacters(cp => Strings_1.isAscii(cp) && Strings_1.isLetterOrUnderscoreOrDigit(cp));
const keywords = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "bool",
    "break",
    "case",
    "catch",
    "char",
    "char16_t",
    "char32_t",
    "class",
    "compl",
    "concept",
    "const",
    "constexpr",
    "const_cast",
    "continue",
    "co_await",
    "co_return",
    "co_yield",
    "decltype",
    "default",
    "delete",
    "do",
    "double",
    "dynamic_cast",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "float",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "int",
    "long",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "private",
    "protected",
    "public",
    "register",
    "reinterpret_cast",
    "requires",
    "return",
    "short",
    "signed",
    "sizeof",
    "static",
    "static_assert",
    "static_cast",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "unsigned",
    "using",
    "virtual",
    "void",
    "volatile",
    "wchar_t",
    "while",
    "xor",
    "xor_eq",
    "override",
    "final",
    "transaction_safe",
    "transaction_safe_dynamic",
    "NULL"
];
const optionalType = "std::unique_ptr";
class CPlusPlusRenderer extends ConvenienceRenderer_1.ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._namespaceNames = _options.namespace.split("::");
        this.typeNamingStyle = _options.typeNamingStyle;
        this.enumeratorNamingStyle = _options.enumeratorNamingStyle;
        this._memberNamingFunction = Naming_1.funPrefixNamer("members", Strings_1.makeNameStyle(_options.memberNamingStyle, legalizeName));
    }
    forbiddenNamesForGlobalNamespace() {
        return keywords;
    }
    forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
    }
    forbiddenForEnumCases(_e, _enumName) {
        return { names: [], includeGlobalForbidden: true };
    }
    makeNamedTypeNamer() {
        return Naming_1.funPrefixNamer("types", Strings_1.makeNameStyle(this.typeNamingStyle, legalizeName));
    }
    namerForObjectProperty() {
        return this._memberNamingFunction;
    }
    makeUnionMemberNamer() {
        return null;
    }
    makeEnumCaseNamer() {
        return Naming_1.funPrefixNamer("enumerators", Strings_1.makeNameStyle(this.enumeratorNamingStyle, legalizeName));
    }
    get needsTypeDeclarationBeforeUse() {
        return true;
    }
    canBeForwardDeclared(t) {
        const kind = t.kind;
        return kind === "class";
    }
    emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, " * ", "/**", " */");
    }
    emitBlock(line, withSemicolon, f, withIndent = true) {
        this.emitLine(line, " {");
        this.preventBlankLine();
        if (withIndent) {
            this.indent(f);
        }
        else {
            f();
        }
        this.preventBlankLine();
        if (withSemicolon) {
            this.emitLine("};");
        }
        else {
            this.emitLine("}");
        }
    }
    emitNamespaces(namespaceNames, f) {
        const namesArray = collection_utils_1.toReadonlyArray(namespaceNames);
        const first = namesArray[0];
        if (first === undefined) {
            f();
        }
        else {
            this.emitBlock(["namespace ", first], false, () => this.emitNamespaces(namesArray.slice(1), f), namesArray.length === 1);
        }
    }
    cppTypeInOptional(nonNulls, ctx, withIssues) {
        if (nonNulls.size === 1) {
            return this.cppType(Support_1.defined(collection_utils_1.iterableFirst(nonNulls)), ctx, withIssues);
        }
        const typeList = [];
        for (const t of nonNulls) {
            if (typeList.length !== 0) {
                typeList.push(", ");
            }
            typeList.push(this.cppType(t, {
                needsForwardIndirection: true,
                needsOptionalIndirection: false,
                inJsonNamespace: ctx.inJsonNamespace
            }, withIssues));
        }
        return ["boost::variant<", typeList, ">"];
    }
    variantType(u, inJsonNamespace) {
        const [maybeNull, nonNulls] = TypeUtils_1.removeNullFromUnion(u, true);
        Support_2.assert(nonNulls.size >= 2, "Variant not needed for less than two types.");
        const indirection = maybeNull !== null;
        const variant = this.cppTypeInOptional(nonNulls, { needsForwardIndirection: !indirection, needsOptionalIndirection: !indirection, inJsonNamespace }, true);
        if (!indirection) {
            return variant;
        }
        return [optionalType, "<", variant, ">"];
    }
    ourQualifier(inJsonNamespace) {
        return inJsonNamespace ? [collection_utils_1.arrayIntercalate("::", this._namespaceNames), "::"] : [];
    }
    jsonQualifier(inJsonNamespace) {
        return inJsonNamespace ? [] : "nlohmann::";
    }
    variantIndirection(needIndirection, typeSrc) {
        if (!needIndirection)
            return typeSrc;
        return ["std::unique_ptr<", typeSrc, ">"];
    }
    cppType(t, ctx, withIssues) {
        const inJsonNamespace = ctx.inJsonNamespace;
        return TypeUtils_1.matchType(t, _anyType => Source_1.maybeAnnotated(withIssues, Annotation_1.anyTypeIssueAnnotation, [this.jsonQualifier(inJsonNamespace), "json"]), _nullType => Source_1.maybeAnnotated(withIssues, Annotation_1.nullTypeIssueAnnotation, [this.jsonQualifier(inJsonNamespace), "json"]), _boolType => "bool", _integerType => "int64_t", _doubleType => "double", _stringType => "std::string", arrayType => [
            "std::vector<",
            this.cppType(arrayType.items, { needsForwardIndirection: false, needsOptionalIndirection: true, inJsonNamespace }, withIssues),
            ">"
        ], classType => this.variantIndirection(ctx.needsForwardIndirection && this.isForwardDeclaredType(classType), [
            "struct ",
            this.ourQualifier(inJsonNamespace),
            this.nameForNamedType(classType)
        ]), mapType => [
            "std::map<std::string, ",
            this.cppType(mapType.values, { needsForwardIndirection: false, needsOptionalIndirection: true, inJsonNamespace }, withIssues),
            ">"
        ], enumType => [this.ourQualifier(inJsonNamespace), this.nameForNamedType(enumType)], unionType => {
            const nullable = TypeUtils_1.nullableFromUnion(unionType);
            if (nullable === null)
                return [this.ourQualifier(inJsonNamespace), this.nameForNamedType(unionType)];
            return [
                optionalType,
                "<",
                this.cppType(nullable, { needsForwardIndirection: false, needsOptionalIndirection: false, inJsonNamespace }, withIssues),
                ">"
            ];
        });
    }
    emitClassMembers(c) {
        this.forEachClassProperty(c, "none", (name, jsonName, property) => {
            this.emitDescription(this.descriptionForClassProperty(c, jsonName));
            this.emitLine(this.cppType(property.type, { needsForwardIndirection: true, needsOptionalIndirection: true, inJsonNamespace: false }, true), " ", name, ";");
        });
    }
    emitClass(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitBlock(["struct ", className], true, () => {
            this.emitClassMembers(c);
        });
    }
    emitClassFunctions(c, className) {
        const ourQualifier = this.ourQualifier(true);
        this.emitBlock(["inline void from_json(const json& _j, struct ", ourQualifier, className, "& _x)"], false, () => {
            this.forEachClassProperty(c, "none", (name, json, p) => {
                const t = p.type;
                if (t instanceof Type_1.UnionType) {
                    const [maybeNull, nonNulls] = TypeUtils_1.removeNullFromUnion(t, true);
                    if (maybeNull !== null) {
                        this.emitLine("_x.", name, " = ", ourQualifier, "get_optional<", this.cppTypeInOptional(nonNulls, {
                            needsForwardIndirection: false,
                            needsOptionalIndirection: false,
                            inJsonNamespace: true
                        }, false), '>(_j, "', Strings_1.stringEscape(json), '");');
                        return;
                    }
                }
                if (t.kind === "null" || t.kind === "any") {
                    this.emitLine("_x.", name, " = ", ourQualifier, 'get_untyped(_j, "', Strings_1.stringEscape(json), '");');
                    return;
                }
                const cppType = this.cppType(t, { needsForwardIndirection: true, needsOptionalIndirection: true, inJsonNamespace: true }, false);
                this.emitLine("_x.", name, ' = _j.at("', Strings_1.stringEscape(json), '").get<', cppType, ">();");
            });
        });
        this.ensureBlankLine();
        this.emitBlock(["inline void to_json(json& _j, const struct ", ourQualifier, className, "& _x)"], false, () => {
            this.emitLine("_j = json::object();");
            this.forEachClassProperty(c, "none", (name, json, _) => {
                this.emitLine('_j["', Strings_1.stringEscape(json), '"] = _x.', name, ";");
            });
        });
    }
    emitEnum(e, enumName) {
        const caseNames = [];
        this.forEachEnumCase(e, "none", name => {
            if (caseNames.length > 0)
                caseNames.push(", ");
            caseNames.push(name);
        });
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("enum class ", enumName, " { ", caseNames, " };");
    }
    emitUnionTypedefs(u, unionName) {
        this.emitLine("typedef ", this.variantType(u, false), " ", unionName, ";");
    }
    emitUnionFunctions(u) {
        const functionForKind = [
            ["bool", "is_boolean"],
            ["integer", "is_number_integer"],
            ["double", "is_number"],
            ["string", "is_string"],
            ["class", "is_object"],
            ["map", "is_object"],
            ["array", "is_array"],
            ["enum", "is_string"]
        ];
        const nonNulls = TypeUtils_1.removeNullFromUnion(u, true)[1];
        const variantType = this.cppTypeInOptional(nonNulls, { needsForwardIndirection: false, needsOptionalIndirection: false, inJsonNamespace: true }, false);
        this.emitBlock(["inline void from_json(const json& _j, ", variantType, "& _x)"], false, () => {
            let onFirst = true;
            for (const [kind, func] of functionForKind) {
                const typeForKind = collection_utils_1.iterableFind(nonNulls, t => t.kind === kind);
                if (typeForKind === undefined)
                    continue;
                this.emitLine(onFirst ? "if" : "else if", " (_j.", func, "())");
                this.indent(() => {
                    this.emitLine("_x = _j.get<", this.cppType(typeForKind, { needsForwardIndirection: true, needsOptionalIndirection: true, inJsonNamespace: true }, false), ">();");
                });
                onFirst = false;
            }
            this.emitLine('else throw "Could not deserialize";');
        });
        this.ensureBlankLine();
        this.emitBlock(["inline void to_json(json& _j, const ", variantType, "& _x)"], false, () => {
            this.emitBlock("switch (_x.which())", false, () => {
                let i = 0;
                for (const t of nonNulls) {
                    this.emitLine("case ", i.toString(), ":");
                    this.indent(() => {
                        this.emitLine("_j = boost::get<", this.cppType(t, {
                            needsForwardIndirection: true,
                            needsOptionalIndirection: true,
                            inJsonNamespace: true
                        }, false), ">(_x);");
                        this.emitLine("break;");
                    });
                    i++;
                }
                this.emitLine('default: throw "Input JSON does not conform to schema";');
            });
        });
    }
    emitEnumFunctions(e, enumName) {
        const ourQualifier = this.ourQualifier(true);
        this.emitBlock(["inline void from_json(const json& _j, ", ourQualifier, enumName, "& _x)"], false, () => {
            let onFirst = true;
            this.forEachEnumCase(e, "none", (name, jsonName) => {
                const maybeElse = onFirst ? "" : "else ";
                this.emitLine(maybeElse, 'if (_j == "', Strings_1.stringEscape(jsonName), '") _x = ', ourQualifier, enumName, "::", name, ";");
                onFirst = false;
            });
            this.emitLine('else throw "Input JSON does not conform to schema";');
        });
        this.ensureBlankLine();
        this.emitBlock(["inline void to_json(json& _j, const ", ourQualifier, enumName, "& _x)"], false, () => {
            this.emitBlock("switch (_x)", false, () => {
                this.forEachEnumCase(e, "none", (name, jsonName) => {
                    this.emitLine("case ", ourQualifier, enumName, "::", name, ': _j = "', Strings_1.stringEscape(jsonName), '"; break;');
                });
                this.emitLine('default: throw "This should not happen";');
            });
        });
    }
    emitTopLevelTypedef(t, name) {
        this.emitLine("typedef ", this.cppType(t, { needsForwardIndirection: true, needsOptionalIndirection: true, inJsonNamespace: false }, true), " ", name, ";");
    }
    emitAllUnionFunctions() {
        this.forEachUniqueUnion("interposing", u => this.sourcelikeToString(this.cppTypeInOptional(TypeUtils_1.removeNullFromUnion(u, true)[1], { needsForwardIndirection: false, needsOptionalIndirection: false, inJsonNamespace: true }, false)), (u) => this.emitUnionFunctions(u));
    }
    emitOptionalHelpers() {
        this.emitLine("template <typename T>");
        this.emitMultiline(`struct adl_serializer<std::unique_ptr<T>> {
    static void to_json(json& j, const std::unique_ptr<T>& opt) {
        if (!opt)
            j = nullptr;
        else
            j = *opt;
    }

    static std::unique_ptr<T> from_json(const json& j) {
        if (j.is_null())
            return std::unique_ptr<T>();
        else
            return std::unique_ptr<T>(new T(j.get<T>()));
    }
};`);
    }
    emitDeclaration(decl) {
        if (decl.kind === "forward") {
            this.emitLine("struct ", this.nameForNamedType(decl.type), ";");
        }
        else if (decl.kind === "define") {
            const t = decl.type;
            const name = this.nameForNamedType(t);
            if (t instanceof Type_1.ClassType) {
                this.emitClass(t, name);
            }
            else if (t instanceof Type_1.EnumType) {
                this.emitEnum(t, name);
            }
            else if (t instanceof Type_1.UnionType) {
                this.emitUnionTypedefs(t, name);
            }
            else {
                return Support_1.panic(`Cannot declare type ${t.kind}`);
            }
        }
        else {
            return Support_1.assertNever(decl.kind);
        }
    }
    emitTypes() {
        if (!this._options.justTypes) {
            this.emitLine("using nlohmann::json;");
            this.ensureBlankLine();
        }
        this.forEachDeclaration("interposing", decl => this.emitDeclaration(decl));
        if (this._options.justTypes)
            return;
        this.forEachTopLevel("leading", (t, name) => this.emitTopLevelTypedef(t, name), t => this.namedTypeToNameForTopLevel(t) === undefined);
        this.emitMultiline(`
inline json get_untyped(const json &j, const char *property) {
    if (j.find(property) != j.end()) {
        return j.at(property).get<json>();
    }
    return json();
}`);
        if (this.haveUnions) {
            this.emitMultiline(`
template <typename T>
inline ${optionalType}<T> get_optional(const json &j, const char *property) {
    if (j.find(property) != j.end())
        return j.at(property).get<${optionalType}<T>>();
    return ${optionalType}<T>();
}`);
        }
    }
    emitSourceStructure() {
        if (this.leadingComments !== undefined) {
            this.emitCommentLines(this.leadingComments);
        }
        else if (!this._options.justTypes) {
            this.emitCommentLines([
                " To parse this JSON data, first install",
                "",
                "     Boost     http://www.boost.org",
                "     json.hpp  https://github.com/nlohmann/json",
                "",
                " Then include this file, and then do",
                ""
            ]);
            this.forEachTopLevel("none", (_, topLevelName) => {
                this.emitLine("//     ", this.ourQualifier(false), topLevelName, " data = nlohmann::json::parse(jsonString);");
            });
        }
        this.ensureBlankLine();
        const guardName = [
            "__QUICKTYPE_",
            collection_utils_1.arrayIntercalate("_", Array.from(this.topLevels.keys()).map(n => legalizeName(Strings_1.allUpperWordStyle(n)))),
            "_HPP__"
        ];
        this.emitLine("#ifndef ", guardName);
        this.emitLine("#define ", guardName);
        this.ensureBlankLine();
        const include = (name) => {
            this.emitLine(`#include ${name}`);
        };
        if (this.haveNamedUnions)
            include("<boost/variant.hpp>");
        if (!this._options.justTypes)
            include('"json.hpp"');
        this.ensureBlankLine();
        if (this._options.justTypes) {
            this.emitTypes();
        }
        else {
            this.emitNamespaces(this._namespaceNames, () => this.emitTypes());
        }
        if (!this._options.justTypes && this.haveNamedTypes) {
            this.ensureBlankLine();
            this.emitNamespaces(["nlohmann"], () => {
                if (this.haveUnions) {
                    this.emitOptionalHelpers();
                }
                this.forEachObject("leading-and-interposing", (c, className) => this.emitClassFunctions(c, className));
                this.forEachEnum("leading-and-interposing", (e, enumName) => this.emitEnumFunctions(e, enumName));
                if (this.haveUnions) {
                    this.ensureBlankLine();
                    this.emitAllUnionFunctions();
                }
            });
        }
        this.ensureBlankLine();
        this.emitLine("#endif");
    }
}
exports.CPlusPlusRenderer = CPlusPlusRenderer;
